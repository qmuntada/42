
#include "wolf.h"

void		render_pointwv(t_env *e, int num, int dist, int tex)
{
	int		pos;
	int		color;

	pos = ((e->vy) * e->texture[tex + 1].bpp / 8) + ((int)e->x * e->texture[tex + 1].sl);
	color = e->texture[tex].img[pos] + \
			e->texture[tex].img[pos + 1] * 256 \
			+ e->texture[tex].img[pos + 2] * 65536;
	pixel_put(e, num, e->px, color);
}

void		render_pointwh(t_env *e, int num, int dist, int tex)
{
	int		pos;
	int		color;

	pos = ((e->vx) * e->texture[tex + 1].bpp / 8) + ((int)e->x * e->texture[tex + 1].sl);
	color = e->texture[tex].img[pos] + \
			e->texture[tex].img[pos + 1] * 256 \
			+ e->texture[tex].img[pos + 2] * 65536;
	pixel_put(e, num, e->px, color);
}


void		render_pointfc(t_env *e, int num, int dist, int tex)
{
	int		pos;
	int		color;

	pos = ((int)e->x * e->texture[tex].bpp / 8) + ((int)e->y * e->texture[tex].sl);
	color = e->texture[tex].img[pos] + \
			e->texture[tex].img[pos + 1] * 256 \
			+ e->texture[tex].img[pos + 2] * 65536;
	pixel_put(e, num, e->px, color);
}

void		draw_wallf(t_env *e, t_vectlst *list, int num)
{
	float	pas;
	int		tex;

	pas = ((float)BLOC / ((list->wfloorbot + list->wfloorsv) - (list->wfloortop - list->wfloorev)));
	pas *= ((float)list->wallf / BLOC);
	e->x = 0 + (list->wfloorsv * pas);
	tex = e->map.texture[(int)floor(list->vector.y / BLOC)][(int)floor(list->vector.x / BLOC)] * 4 + 2;
	e->px = list->wfloorbot;
	while (e->px >= list->wfloortop)
	{
		e->x += (e->x > 64.0 ? -64.0 : 0);
		if (e->px < e->img.height && e->px >= 0 && e->x >= 0 && e->x <= 64)
		{
			if (list->side == 'v')
				render_pointwv(e, num, list->vector.dist, tex + 1);
			else
				render_pointwh(e, num, list->vector.dist, tex);
		}
		e->x += pas;
		e->px -= 1;
	}
}

void		draw_wallc(t_env *e, t_vectlst *list, int num)
{
	float	pas;
	int		tex;

	pas = ((float)BLOC / ((list->wceiltop + list->wceilev) - (list->wceilbot - list->wceilsv)));
	pas *= ((512.0 - (float)list->wallc) / BLOC);
	e->x = 64 - (list->wceilsv * pas);
	tex = e->map.texture[(int)floor(list->vector.y / BLOC)][(int)floor(list->vector.x / BLOC)] * 4 + 2;
	e->px = list->wceilbot;
	while (e->px <= list->wceiltop)
	{
		e->x += (e->x < 0 ? 64 : 0);
		if (e->px < e->img.height && e->px >= 0 && e->x >= 0 && e->x <= 64)
		{
			if (list->side == 'v')
				render_pointwv(e, num, list->vector.dist, tex + 1);
			else
				render_pointwh(e, num, list->vector.dist, tex);
		}
		e->x -= pas;
		e->px += 1;
	}
}

void		draw_floor(t_env *e, t_vectlst *list, int num)
{
	float	pasx;
	float	pasy;
	float	pas;
	int		tex;

	pas = (list->floorbot + list->floorsv) - (list->floortop - list->floorev);
	pasx = (-(e->x - list->vector.uvx)) / pas;
	pasy = (-(e->y - list->vector.uvy)) / pas;
	e->x += (list->floorsv * pasx);
	e->y += (list->floorsv * pasy);
	tex = e->map.texture[(int)floor(e->ay / BLOC)][(int)floor(e->ax / BLOC)] * 4 + 1;
	e->px = list->floorbot;
	while (e->px >= list->floortop)
	{
		if (e->px < e->img.height && e->px >= 0 && e->x >= 0 && e->x <= 64 && e->y >= 0 && e->y <= 64)
			render_pointfc(e, num, list->vector.dist, tex);
		e->px = e->px - 1;
		e->x += pasx;
		e->y += pasy;
	}
}

void		draw_ceil(t_env *e, t_vectlst *list, int num)
{
	float	pasx;
	float	pasy;
	float	pas;
	int		tex;

	pas = (list->ceilbot + list->ceilsv) - (list->ceiltop - list->ceilev);
	pasx = (-(e->x - list->vector.uvx)) / pas;
	pasy = (-(e->y - list->vector.uvy)) / pas;
	e->x += (list->ceilsv * pasx);
	e->y += (list->ceilsv * pasy);
	tex = e->map.texture[(int)floor(e->ay / BLOC)][(int)floor(e->ax / BLOC)] * 4 + 4;
	e->px = list->ceilbot;
	while (e->px <= list->ceiltop)
	{
		if (e->px < e->img.height && e->px >= 0 && e->x >= 0 && e->x <= 64 && e->y >= 0 && e->y <= 64)
			render_pointfc(e, num, list->vector.dist, tex);
		e->px = e->px + 1;
		e->x -= pasx;
		e->y -= pasy;
	}
}


void		display_line(t_env *e, t_vectlst *list, int num)
{
	int		n;
	int		tmp1;
	int		tmp2;

	e->ax = e->p.x;
	e->ay = e->p.y;
	e->x = 0;
	e->y = 0;
	tmp1 = e->x;
	tmp2 = e->y;
	n = e->line[num].iter;
	while (list && n-- > 0)
	{
		e->dist = list->vector.dist;
		draw_ceil(e, list, num);
		e->x = tmp1;
		e->y = tmp2;
		draw_floor(e, list, num);
		e->vy = (int)list->vector.y % 64;
		e->vx = (int)list->vector.x % 64;
		draw_wallf(e, list, num);
		draw_wallc(e, list, num);
		e->ax = list->vector.x;
		e->ay = list->vector.y;
		e->y = (int)list->vector.y % 64;
		e->x = (int)list->vector.x % 64;
		tmp1 = e->x;
		tmp2 = e->y;
		list = list->next;
	}
}
